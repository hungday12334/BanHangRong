# Minimal console output profile for mvn spring-boot:run
spring.main.banner-mode=off
spring.output.ansi.enabled=ALWAYS

# Reduce logging noise
logging.level.root=ERROR
logging.level.org.springframework.boot.web.embedded.tomcat=ERROR
logging.level.org.apache.catalina=ERROR
logging.level.org.hibernate=ERROR
logging.level.org.springframework=ERROR

# Keep our app logger at INFO for status messages
logging.level.banhangrong.su25=INFO

# JPA: for the simple profile we'll use the embedded H2 DB and allow schema updates
# (the production profile should use the real MySQL settings in application.properties)

# Hikari: don't fail fast; limit connection attempts to be quick
spring.datasource.hikari.initialization-fail-timeout=-1
spring.datasource.hikari.connection-timeout=5000

# DB init
spring.sql.init.continue-on-error=true

# Web server port (default 8080)
server.port=8080

# Externalize secrets via env / .env file (see .env.example)
# Spring Boot will import a local .env file if present (NOT committed) thanks to spring.config.import below.
spring.config.import=optional:file:.env[.properties]

# DB connection composed from environment variables with safe defaults (except password)
spring.datasource.url=jdbc:mysql://${DB_HOST:smiledev.id.vn}:3306/${DB_NAME:smiledev_wap}?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true&connectTimeout=${DB_CONNECT_TIMEOUT:4000}&socketTimeout=${DB_SOCKET_TIMEOUT:60000}&tcpKeepAlive=true&useConfigs=maxPerformance&rewriteBatchedStatements=true
spring.datasource.username=${DB_USERNAME:smiledev_wap}
spring.datasource.password=${DB_PASSWORD:}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Hibernate dialect and schema strategy for MySQL
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
spring.jpa.hibernate.ddl-auto=update

# ---- Performance tuning (Hikari + Hibernate) ----
# Pool sizing: small but warm
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=60000
# Recycle connections a bit earlier than typical MySQL wait_timeout (set appropriately on server)
# Hikari: recycle connections a bit earlier than server wait_timeout (~9 minutes)
spring.datasource.hikari.max-lifetime=540000
# Keepalive ping every 5 minutes to prevent idle disconnects
spring.datasource.hikari.keepalive-time=300000

# Increase wait for first connection slightly (remote network) while keeping feedback fast
# (Adjusted above from 2000 -> 5000 for remote DB latency)

# Hibernate batching (only effective if not using IDENTITY for primary keys)
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.batch_versioned_data=true

# Disable Open Session in View (avoid holding connections too long during template rendering)
spring.jpa.open-in-view=false

# (Optional) If metadata lookups are slow and you do NOT rely on Hibernate reading DB metadata dynamically, you can experiment with:
# spring.jpa.properties.hibernate.boot.allow_jdbc_metadata_access=false

# (Optional) After schema stabilized, change ddl-auto to validate or none to skip schema diff work at startup:
# spring.jpa.hibernate.ddl-auto=validate

# ---- Imgbb (online image upload) ----
# Simple profile imports .env; you can set either of these keys in .env:
# IMGBB_API_KEY=your_key_here
# or
# imgbb.api.key=your_key_here