<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - Customer Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/img/kua654ms.png" />
    <meta name="_csrf" th:if="${_csrf != null}" th:content="${_csrf.token}">
    <meta name="_csrf_header" th:if="${_csrf != null}" th:content="${_csrf.headerName}">
    <meta name="theme-color" content="#0ea5e9" />
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        /* Customer-specific variables */
        :root {
            --bg: #f5f7fb;
            --bg-elev: #ffffff;
            --card: #ffffff;
            --ink: #0f172a;
            --text: #0f172a;
            --muted: #6b7280;
            --brand: #0ea5e9;
            --accent: #0ea5e9;
            --chip: #e5e7eb;
            --line: #eaeef4;
            --border: #eaeef4;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            color: var(--ink);
            background: var(--bg);
        }

        /* Improved wrapper layout with proper flex */
        .wrapper {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Enhanced topbar with better spacing and shadow */
        .topbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 20px;
            border-bottom: 1px solid var(--line);
            background: var(--card);
            flex-wrap: nowrap;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.5px;
            font-size: 18px;
            color: var(--brand);
            white-space: nowrap;
        }

        .nav {
            display: flex;
            gap: 8px;
            margin: 0 12px;
            flex: 1;
        }

        .nav a {
            text-decoration: none;
            color: #111827;
            font-weight: 500;
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .nav a:hover {
            background: #f3f4f6;
            color: var(--brand);
        }

        .top-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .user-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #111827;
            border: 1px solid var(--line);
            padding: 8px 12px;
            border-radius: 6px;
            background: #fff;
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .user-btn:hover {
            border-color: var(--brand);
            background: #f0f9ff;
        }

        .wallet-badge {
            margin-left: 4px;
            padding: 4px 8px;
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 4px;
            font-weight: 600;
            color: #0369a1;
            font-size: 12px;
        }

        .cart {
            position: relative;
            width: 36px;
            height: 36px;
            display: grid;
            place-items: center;
            border: 1px solid var(--line);
            border-radius: 6px;
            text-decoration: none;
            color: #111827;
            font-size: 18px;
            transition: all 0.2s;
        }

        .cart:hover {
            border-color: var(--brand);
            background: #f0f9ff;
        }

        /* Improved chat page layout with proper flex */
        .chat-page {
            padding: 16px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chat-wrapper {
            display: flex;
            gap: 0;
            flex: 1;
            background: var(--bg-elev, #ffffff);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-height: 0;
        }

        /* Loader Styles */
        .app-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        body:not(.loading) .app-loader {
            opacity: 0;
            pointer-events: none;
        }

        .loader-core {
            text-align: center;
        }

        .orbital {
            position: relative;
            width: 100px;
            height: 100px;
            margin: 0 auto 20px;
        }

        .nucleus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
        }

        .loader-logo {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .orbit {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(14, 165, 233, 0.2);
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }

        .orbit-a { width: 60px; height: 60px; }
        .orbit-b { width: 80px; height: 80px; animation-duration: 3s; }
        .orbit-c { width: 100px; height: 100px; animation-duration: 4s; }

        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .load-text {
            font-size: 14px;
            color: var(--muted);
            margin-top: 10px;
        }

        /* Icon fallback */
        .ti, .ti-messages, .ti-message-circle, .ti-send {
            font-family: 'tabler-icons', sans-serif;
            font-style: normal;
            font-weight: normal;
        }

        .ti::before {
            content: "üí¨";
        }

        .ti-send::before {
            content: "‚û§";
        }

        .connection-status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            z-index: 9999;
            display: none;
        }

        .connection-status.connecting { background: #ffc107; color: #000; display: block; }
        .connection-status.connected { background: #28a745; color: white; display: block; }
        .connection-status.disconnected { background: #dc3545; color: white; display: block; }

        /* Improved sidebar with better responsive sizing */
        .conversations-sidebar {
            width: 320px;
            border-right: 1px solid var(--border, #e5e7eb);
            display: flex;
            flex-direction: column;
            background: var(--bg-elev, #ffffff);
            min-height: 0;
        }

        .conversations-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border, #e5e7eb);
            background: var(--bg-elev, #ffffff);
            flex-shrink: 0;
        }

        .conversations-header h2 {
            font-size: 20px;
            font-weight: 700;
            color: var(--text, #0f172a);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-info {
            padding: 12px 20px;
            background: var(--bg-elev, #ffffff);
            border-bottom: 1px solid var(--border, #e5e7eb);
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 16px;
            flex-shrink: 0;
        }

        .avatar.seller {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Improved conversations list with proper scrolling */
        .conversations-list {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .conversation-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid #f0f0f0;
        }

        .conversation-item:hover {
            background: #f9f9f9;
        }

        .conversation-item.active {
            background: #f0f9ff;
            border-left: 3px solid var(--accent, #0ea5e9);
            padding-left: 13px;
        }

        .conversation-info {
            flex: 1;
            min-width: 0;
            margin-left: 12px;
        }

        .conversation-name {
            font-weight: 600;
            color: var(--text, #0f172a);
            font-size: 14px;
            margin-bottom: 2px;
        }

        .conversation-last-message {
            color: var(--muted, #6b7280);
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
        }

        .unread-badge {
            background: var(--accent, #0ea5e9);
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Improved main chat area with proper flex */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg, #f5f7fb);
            min-height: 0;
        }

        .chat-header {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border, #e5e7eb);
            display: flex;
            align-items: center;
            background: var(--bg-elev, #ffffff);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        /* Improved messages container with proper flex */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
            background: var(--bg, #f5f7fb);
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .message {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-end;
            animation: fadeIn 0.2s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.sent {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
            margin: 0 8px;
            flex-shrink: 0;
        }

        .message-avatar.seller {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .message-content {
            max-width: 65%;
        }

        .message-bubble {
            padding: 10px 14px;
            border-radius: 16px;
            word-wrap: break-word;
            display: inline-block;
            font-size: 14px;
            line-height: 1.4;
        }
            background: var(--bg-elev, white);
        .message.received .message-bubble {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            color: var(--text, #0f172a);
            border-bottom-left-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .message.sent .message-bubble {
            background: var(--accent, #0ea5e9);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message-time {
            font-size: 11px;
            color: var(--muted, #9ca3af);
            padding: 0 8px;
            margin-top: 2px;
        }

        /* === ENHANCED CHAT FEATURES === */

        .message-wrapper {
            position: relative;
            display: flex;
            margin-bottom: 12px;
        }

        .message-wrapper.sent {
            flex-direction: row-reverse;
        }

        /* Message Actions Toolbar - appears on hover */
        .message-actions {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: none !important;
            flex-direction: row;
            gap: 2px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 10px;
            padding: 2px 4px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            z-index: 10;
        }

        .message-wrapper:hover .message-actions {
            display: flex !important;
            flex-direction: row;
        }

        .message-wrapper.sent .message-actions {
            left: -15px;
        }

        /* Tin nh·∫Øn c·ªßa ƒê·ªêI PH∆Ø∆†NG (received) -> Actions ·ªü B√äN PH·∫¢I C·ª∞C K·ª≤ S√ÅT */
        .message-wrapper.received .message-actions {
            right: -15px;
        }

        .message-action-btn {
            background: transparent;
            border: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.15s ease;
            padding: 0;
            line-height: 1;
        }

        .message-action-btn:hover {
            background: #f3f4f6;
            transform: scale(1.15);
        }

        .message-action-btn.emoji-btn:hover {
            background: #fef3c7;
        }

        .message-action-btn.reply-btn:hover {
            background: #dbeafe;
        }

        .message-action-btn.delete-btn:hover {
            background: #fee2e2;
        }

        /* Emoji Reaction Picker (small popup) */
        .reaction-picker {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 20px;
            padding: 8px 12px;
            display: none;
            flex-direction: row;
            gap: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 20;
            margin-bottom: 8px;
        }

        .reaction-picker.show {
            display: flex;
        }

        .reaction-option {
            background: transparent;
            border: none;
            font-size: 24px;
            padding: 6px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .reaction-option:hover {
            background: #f3f4f6;
            transform: scale(1.2);
        }

        /* Message Reactions Display */
        .message-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
            padding: 0 8px;
        }

        .reaction-badge {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 12px;
            padding: 3px 8px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reaction-badge:hover {
            background: #f9fafb;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .reaction-badge.user-reacted {
            background: #dbeafe;
            border-color: #60a5fa;
        }

        /* Compact Reaction Badge (single badge showing most popular) */
        .reaction-badge-compact {
            background: var(--bg-elev, #ffffff);
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 12px;
            padding: 4px 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .reaction-badge-compact:hover {
            background: var(--card, #f9fafb);
            transform: scale(1.08);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
        }

        .reaction-badge-compact.user-reacted {
            background: var(--accent, #0ea5e9);
            background: rgba(14, 165, 233, 0.15);
            border-color: var(--accent, #60a5fa);
        }

        .reaction-emoji {
            font-size: 16px;
        }

        .reaction-count {
            font-size: 12px;
            font-weight: 600;
            color: var(--text, #0f172a);
        }

        /* Reaction Details Popup (centered) */
        .reaction-details-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

        .reaction-details-overlay.show {
            display: flex;
        }

        .reaction-details-popup {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.2s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .reaction-details-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f9fafb;
            border-radius: 12px 12px 0 0;
        }

        .reaction-details-title {
            font-weight: 700;
            font-size: 16px;
            color: #111827;
        }

        .reaction-details-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .reaction-details-close:hover {
            background: #e5e7eb;
            color: #111827;
        }

        .reaction-details-content {
            padding: 16px 20px;
        }

        .reaction-group {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border, #f3f4f6);
        }

        .reaction-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .reaction-group-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .reaction-group-emoji {
            font-size: 24px;
        }

        .reaction-group-count {
            font-weight: 600;
            color: var(--muted, #6b7280);
            font-size: 14px;
        }

        .reaction-user-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .reaction-user-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--card, #f9fafb);
            border-radius: 8px;
            border: 1px solid var(--border, transparent);
        }

        .reaction-user-name {
            font-size: 14px;
            color: var(--text, #111827);
            font-weight: 500;
        }

        .reaction-remove-btn {
            background: #fee2e2;
            color: #dc2626;
            border: none;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reaction-remove-btn:hover {
            background: #fecaca;
            transform: scale(1.05);
        }

        /* Reply Status Bar */
        .reply-status-bar {
            display: none;
            background: #f9fafb;
            border-left: 3px solid var(--accent, #0ea5e9);
            padding: 10px 14px;
            margin-bottom: 8px;
            border-radius: 8px;
            position: relative;
        }

        .reply-status-bar.show {
            display: block;
        }

        .reply-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .reply-status-sender {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent, #0ea5e9);
        }

        .reply-status-close {
            background: none;
            border: none;
            color: var(--muted, #6b7280);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .reply-status-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: var(--text, #0f172a);
        }

        .reply-status-content {
            font-size: 13px;
            color: var(--muted, #6b7280);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Replied Message Quote in Message Bubble */
        .message-reply-quote {
            background: rgba(0, 0, 0, 0.05);
            border-left: 3px solid var(--accent, #0ea5e9);
            padding: 8px 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .message-reply-quote:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .message.sent .message-reply-quote {
            background: rgba(255, 255, 255, 0.3);
        }

        .message.sent .message-reply-quote:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .reply-quote-sender {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent, #0ea5e9);
            margin-bottom: 2px;
        }

        .reply-quote-content {
            font-size: 12px;
            color: var(--text, #0f172a);
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Message Highlight Animation */
        .message-highlight {
            animation: highlightPulse 1.5s ease-out;
        }

        @keyframes highlightPulse {
            0%, 100% { background: transparent; }
            50% { background: rgba(14, 165, 233, 0.2); border-radius: 12px; }
        }

        /* Deleted Message Styles */
        .message-bubble.deleted {
            opacity: 0.5;
            background: #f3f4f6 !important;
            color: var(--muted, #9ca3af) !important;
            font-style: italic;
            position: relative;
        }

        .deleted-message-icon {
            display: none;
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            font-size: 16px;
            opacity: 0.6;
            transition: all 0.2s ease;
        }

        .message-bubble.deleted:hover .deleted-message-icon {
            display: block;
        }

        .deleted-message-icon:hover {
            opacity: 1;
            transform: translateY(-50%) scale(1.2);
        }

        /* Reaction Users Popup */
        .reaction-users-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            min-width: 280px;
            max-width: 400px;
            display: none;
        }

        .reaction-users-popup.show {
            display: block;
        }

        .reaction-users-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            z-index: 1000;
            display: none;
        }

        .reaction-users-overlay.show {
            display: block;
        }

        .reaction-users-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border, #e5e7eb);
        }

        .reaction-users-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text, #0f172a);
        }

        .reaction-users-close {
            background: none;
            border: none;
            color: var(--muted, #6b7280);
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .reaction-users-close:hover {
            background: #f3f4f6;
            color: var(--text, #0f172a);
        }

        .reaction-group {
            margin-bottom: 12px;
        }

        .reaction-group-emoji {
            font-size: 20px;
            margin-right: 8px;
        }

        .reaction-user-list {
            display: inline;
            font-size: 14px;
            color: var(--text, #0f172a);
        }

        .remove-reaction-hint {
            font-size: 12px;
            color: var(--muted, #6b7280);
            font-style: italic;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border, #e5e7eb);
        }

        /* Improved input container with better styling */
        .chat-input-container {
            padding: 16px 20px;
            border-top: 1px solid var(--border, #e5e7eb);
            background: var(--bg-elev, #ffffff);
            flex-shrink: 0;
        }

        .chat-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            border: 1px solid var(--border, #e5e7eb);
            background: var(--bg, #f5f7fb);
            color: var(--text, #0f172a);
            border-radius: 20px;
            padding: 10px 16px;
            font-size: 14px;
            outline: none;
            font-family: inherit;
            transition: all 0.2s;
        }

        .chat-input:focus {
            border-color: var(--accent, #0ea5e9);
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }

        .btn-send {
            background: var(--accent, #0ea5e9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            font-size: 16px;
        }

        .btn-send:hover:not(:disabled) {
            background: #0284c7;
            transform: scale(1.05);
        }

        .btn-send:active:not(:disabled) {
            transform: scale(0.95);
        }

        .btn-send:disabled {
            background: var(--muted, #d1d5db);
            cursor: not-allowed;
        }

        .welcome-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--muted, #9ca3af);
            text-align: center;
            padding: 40px 20px;
            background: var(--bg, #f5f7fb);
        }


        .welcome-screen h3 {
            font-size: 24px;
            font-weight: 600;
            color: var(--text, #0f172a);
            margin: 0 0 12px 0;
        }

        .welcome-screen p {
            font-size: 15px;
            margin: 0;
            color: var(--muted, #6b7280);
        }

        .hidden {
            display: none !important;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Improved scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        #chatArea {
            display: flex !important;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        /* Added responsive design for mobile and tablet */
        @media (max-width: 768px) {
            .topbar {
                padding: 10px 12px;
                gap: 8px;
            }

            .brand {
                font-size: 16px;
            }

            .nav {
                display: none;
            }

            .chat-page {
                padding: 8px;
            }

            .conversations-sidebar {
                width: 280px;
            }

            .message-content {
                max-width: 80%;
            }

            .chat-input {
                font-size: 13px;
                padding: 8px 12px;
            }
        }

        @media (max-width: 480px) {
            .conversations-sidebar {
                display: none;
            }

            .chat-wrapper {
                border-radius: 0;
            }

            .message-content {
                max-width: 90%;
            }

            .chat-page {
                padding: 0;
            }

            .topbar {
                padding: 8px 10px;
            }

            .top-actions {
                gap: 8px;
            }

            .user-btn {
                padding: 6px 8px;
                font-size: 12px;
            }

            .wallet-badge {
                display: none;
            }
        }

    /*    ....................*/
        /* === üîß FIX SCROLLING & LAYOUT ENHANCEMENT === */

        /* Gi·ªØ wrapper chi·∫øm to√†n m√†n h√¨nh */
        .wrapper {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Chat page chi·∫øm ph·∫ßn c√≤n l·∫°i sau topbar */
        .chat-page {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0; /* b·ªè padding ƒë·ªÉ full khung */
        }

        /* Hai c·ªôt ch√≠nh: danh s√°ch + khung chat */
        .chat-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
            border-radius: 0;
            background: var(--bg-elev, #fff);
        }

        /* Sidebar (customer list) cu·ªôn ri√™ng bi·ªát */
        .conversations-sidebar {
            width: 320px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border, #e5e7eb);
            background: var(--bg-elev, #fff);
            overflow-y: auto;
        }

        /* Khung chat ch√≠nh */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg, #f5f7fb);
        }

        /* Tin nh·∫Øn cu·ªôn ƒë·ªôc l·∫≠p */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            scroll-behavior: smooth;
        }

        /* √î nh·∫≠p c·ªë ƒë·ªãnh ·ªü ƒë√°y, kh√¥ng cu·ªôn */
        .chat-input-container {
            position: sticky;
            bottom: 0;
            background: var(--bg-elev, #ffffff);
            border-top: 1px solid var(--border, #e5e7eb);
            padding: 14px 20px;
            z-index: 5;
        }

        /* Plus Button for Features */
        .btn-plus {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border: none;
            border-radius: 50%;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
            font-size: 18px;
            flex-shrink: 0;
            position: relative;
        }

        .btn-plus:hover {
            transform: scale(1.08) rotate(90deg);
            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
        }

        /* Features Menu */
        .features-menu {
            position: absolute;
            bottom: 70px;
            left: 20px;
            background: linear-gradient(135deg, #ffffff, #f9fafb);
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 12px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            animation: slideUpFade 0.2s ease;
        }

        .features-menu.show { display: flex; }

        @keyframes slideUpFade {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .feature-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text, #0f172a);
        }

        .feature-item:hover {
            background: #f3f4f6;
            transform: translateX(4px);
        }

        .feature-item i {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        .feature-item.image i { color: #3b82f6; }
        .feature-item.emoji i { color: #fbbf24; }
        .feature-item.file i { color: #10b981; }
        .feature-item.location i { color: #ef4444; }

        #imageInput, #fileInput { display: none; }

        /* Emoji Picker */
        .emoji-picker {
            position: absolute;
            bottom: 70px;
            left: 20px;
            background: #ffffff;
            border: 1px solid var(--border, #e5e7eb);
            border-radius: 12px;
            padding: 16px;
            display: none;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            width: 320px;
            max-height: 350px;
            overflow-y: auto;
            animation: slideUpFade 0.2s ease;
        }

        .emoji-picker.show { display: block; }

        .emoji-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border, #e5e7eb);
        }

        .emoji-picker-header h4 {
            color: var(--text, #0f172a);
            font-size: 14px;
            font-weight: 600;
            margin: 0;
        }

        .emoji-close {
            background: none;
            border: none;
            color: var(--muted, #6b7280);
            cursor: pointer;
            font-size: 18px;
            padding: 4px;
            transition: color 0.2s ease;
        }

        .emoji-close:hover { color: var(--text, #0f172a); }

        .emoji-categories {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            overflow-x: auto;
        }

        .emoji-category-btn {
            background: #f3f4f6;
            border: 1px solid var(--border, #e5e7eb);
            color: var(--text, #0f172a);
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .emoji-category-btn:hover,
        .emoji-category-btn.active {
            background: #e0f2fe;
            border-color: #0ea5e9;
            color: #0369a1;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .emoji-item {
            background: transparent;
            border: none;
            font-size: 24px;
            padding: 8px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .emoji-item:hover {
            background: #f3f4f6;
            transform: scale(1.2);
        }

        /* Upload Preview */
        .upload-preview {
            display: none;
            padding: 12px;
            background: #f9fafb;
            border-radius: 12px;
            margin-bottom: 8px;
            position: relative;
        }

        .upload-preview.show {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .upload-preview img {
            max-width: 80px;
            max-height: 80px;
            border-radius: 8px;
            object-fit: cover;
        }

        .upload-preview-info {
            flex: 1;
            color: var(--text, #0f172a);
            font-size: 13px;
        }

        .upload-preview-remove {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            color: #ef4444;
            border-radius: 8px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upload-preview-remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        /* Khi c√≥ nhi·ªÅu tin nh·∫Øn, ch·ªâ ph·∫ßn chat-messages cu·ªôn */
        .chat-main #chatArea {
            display: flex !important;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        /* Khi m·ªü khung chat, ƒë·∫£m b·∫£o tin nh·∫Øn m·ªõi lu√¥n hi·ªÉn th·ªã */
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }



    </style>
</head>
<body class="loading enhanced-dashboard" th:attr="data-user-type=${user != null ? user.userType : 'GUEST'}" data-app-root>
<!-- GLOBAL APP LOADER -->
<div id="appLoader" class="app-loader" role="status" aria-live="polite">
    <div class="loader-core">
        <div class="orbital" aria-hidden="true">
            <div class="nucleus">
                <img class="loader-logo" src="/img/kua654ms.png" alt="Logo" decoding="async" loading="eager" data-logo-light="/img/kua654ms.png" data-logo-dark="/img/white.png" />
            </div>
            <div class="orbit orbit-a"><span></span></div>
            <div class="orbit orbit-b"><span></span></div>
            <div class="orbit orbit-c"><span></span></div>
            <div class="rings">
                <div class="ring r1"></div>
                <div class="ring r2"></div>
                <div class="ring r3"></div>
            </div>
        </div>
        <div class="progress-wrap" aria-hidden="true">
            <div class="progress-bar" data-loader-progress></div>
        </div>
        <div class="load-text" data-loader-text>Initializing...</div>
        <div class="load-tip" data-loader-tip></div>
    </div>
</div>

<div id="connectionStatus" class="connection-status"></div>

<!-- Customer Header -->
<div class="wrapper">
    <div class="topbar">
        <div class="brand">BanHangRong</div>
        <nav class="nav">
            <a href="/customer/dashboard">Home</a>
            <a href="/categories">Category</a>
            <a href="/customer/chat" style="font-weight: 600; color: #0ea5e9;">üí¨ Chat</a>
            <a href="/customer/support">Support</a>
        </nav>
        <div class="top-actions">
            <div class="user">
                <button id="userMenuBtn" class="user-btn" type="button">
                    <span th:text="${user != null ? user.username : 'User'}">User</span>
                    <span class="wallet-badge" th:if="${user != null}">
                        üí∞ <span th:text="${user != null and user.balance != null ? #numbers.formatDecimal(user.balance, 0, 'COMMA', 0, 'POINT') + '‚Ç´' : '0‚Ç´'}">0‚Ç´</span>
                    </span>
                </button>
            </div>
            <a href="/cart" class="cart">üõí</a>
        </div>
    </div>

    <!-- Chat Content -->
    <div class="chat-page">
        <div class="chat-wrapper">
            <!-- Conversations Sidebar -->
            <div class="conversations-sidebar">
                <div class="conversations-header">
                    <h2><i class="ti ti-messages"></i> Messages</h2>
                </div>
                <div class="user-info">
                    <div class="avatar" id="currentUserAvatar">
                        <img th:if="${user != null && user.avatarUrl != null}"
                             th:src="@{${user.avatarUrl}}" alt="Avatar" />
                        <span th:if="${user == null || user.avatarUrl == null}"
                              th:text="${user != null ? (user.fullName != null ? #strings.substring(user.fullName, 0, 2) : #strings.substring(user.username, 0, 2)) : 'U'}">U</span>
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div class="conversation-name" th:text="${user != null ? (user.fullName != null ? user.fullName : user.username) : 'User'}">User</div>
                        <div class="conversation-last-message" th:text="${user != null ? user.userType : 'Guest'}">Guest</div>
                    </div>
                </div>
                <div class="conversations-list" id="conversationsList">
                    <!-- Conversations will be loaded here -->
                </div>
            </div>

            <!-- Main Chat Area -->
            <div class="chat-main">
                <div id="welcomeScreen" class="welcome-screen" style="display: flex;">
                    <div style="font-size: 80px; margin-bottom: 24px;">üí¨</div>
                    <h3>Welcome to Chat</h3>
                    <p>Select a seller to start messaging</p>
                </div>

                <div id="chatArea" class="hidden" style="display: none !important; flex-direction: column; flex: 1; min-height: 0;">
                    <div class="chat-header">
                        <div class="avatar" id="chatHeaderAvatar"></div>
                        <div style="margin-left: 12px; flex: 1; min-width: 0;">
                            <div class="conversation-name" id="chatHeaderName"></div>
                            <div class="conversation-last-message">Active</div>
                        </div>
                    </div>

                    <div class="chat-messages" id="chatMessages">
                        <!-- Messages will be loaded here -->
                    </div>

                    <div class="chat-input-container">
                        <!-- Reply Status Bar -->
                        <div class="reply-status-bar" id="replyStatusBar">
                            <div class="reply-status-header">
                                <span class="reply-status-sender" id="replyStatusSender"></span>
                                <button class="reply-status-close" onclick="cancelReply()">‚úï</button>
                            </div>
                            <div class="reply-status-content" id="replyStatusContent"></div>
                        </div>

                        <!-- Upload Preview -->
                        <div class="upload-preview" id="uploadPreview">
                            <img id="previewImage" alt="Preview" style="display: none;">
                            <div class="upload-preview-info" id="previewInfo"></div>
                            <button class="upload-preview-remove" onclick="clearUpload()">‚úï</button>
                        </div>

                        <!-- Features Menu -->
                        <div class="features-menu" id="featuresMenu">
                            <div class="feature-item image" onclick="openImageUpload()">
                                <span>üì∑</span>
                                <span>G·ª≠i ·∫£nh</span>
                            </div>
                            <div class="feature-item emoji" onclick="toggleEmojiPicker()">
                                <span>üòÄ</span>
                                <span>Emoji</span>
                            </div>
                            <div class="feature-item file" onclick="openFileUpload()">
                                <span>üìé</span>
                                <span>ƒê√≠nh k√®m file</span>
                            </div>
                        </div>

                        <!-- Emoji Picker -->
                        <div class="emoji-picker" id="emojiPicker">
                            <div class="emoji-picker-header">
                                <h4>Ch·ªçn Emoji</h4>
                                <button class="emoji-close" onclick="closeEmojiPicker()">‚úï</button>
                            </div>
                            <div class="emoji-categories">
                                <button class="emoji-category-btn active" data-category="recent">G·∫ßn ƒë√¢y</button>
                                <button class="emoji-category-btn" data-category="smileys">üòÄ M·∫∑t c∆∞·ªùi</button>
                                <button class="emoji-category-btn" data-category="gestures">üëã C·ª≠ ch·ªâ</button>
                                <button class="emoji-category-btn" data-category="objects">üéÅ ƒê·ªì v·∫≠t</button>
                            </div>
                            <div class="emoji-grid" id="emojiGrid"></div>
                        </div>

                        <!-- Hidden file inputs -->
                        <input type="file" id="imageInput" accept="image/*" onchange="handleImageUpload(event)" />
                        <input type="file" id="fileInput" accept=".pdf,.doc,.docx,.txt,.zip" onchange="handleFileUpload(event)" />

                        <div class="chat-input-wrapper">
                            <button class="btn-plus" id="btnPlus" onclick="toggleFeaturesMenu()">+</button>
                            <input type="text" class="chat-input" id="messageInput"
                                   placeholder="Type a message..."
                                   maxlength="5000"
                                   oninput="updateCharCount()"
                                   onkeypress="handleKeyPress(event)">
                            <span id="charCount" style="color: #999; font-size: 12px; margin-right: 4px; display: none; white-space: nowrap;">0/5000</span>
                            <button class="btn-send" id="sendBtn" onclick="sendMessage()">
                                <i class="ti ti-send"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Customer Wrapper End -->

<!-- Reaction Details Popup (Centered) -->
<div class="reaction-details-overlay" id="reactionDetailsOverlay" onclick="closeReactionDetails(event)">
    <div class="reaction-details-popup" onclick="event.stopPropagation()">
        <div class="reaction-details-header">
            <div class="reaction-details-title">Reactions</div>
            <button class="reaction-details-close" onclick="closeReactionDetails()">√ó</button>
        </div>
        <div class="reaction-details-content" id="reactionDetailsContent">
            <!-- Content will be populated by JavaScript -->
        </div>
    </div>
</div>

<!-- Old Reaction Users Popup (keep for compatibility) -->
<div class="reaction-users-overlay" id="reactionUsersOverlay" onclick="closeReactionPopup()"></div>
<div class="reaction-users-popup" id="reactionUsersPopup">
    <div class="reaction-users-header">
        <div class="reaction-users-title">Reactions</div>
        <button class="reaction-users-close" onclick="closeReactionPopup()">‚úï</button>
    </div>
    <div id="reactionUsersContent"></div>
</div>

<script th:inline="javascript">
    /*<![CDATA[*/
    const currentUser = /*[[${user}]]*/ null;

    if (!currentUser || !currentUser.userId) {
        alert('Please login first');
        window.location.href = '/login';
    }

    let stompClient = null;
    let currentConversation = null;
    let conversations = [];
    let subscriptions = {};
    let isConnected = false;
    let messageQueue = [];
    let lastMessageTime = 0;
    const RATE_LIMIT_MS = 100;
    const MAX_MESSAGE_LENGTH = 5000;
    const LAST_CONVERSATION_KEY = 'lastConversationId_' + currentUser.userId;

    // Notification settings
    let notificationPermission = 'default';
    let notificationSound = null;

    // Request notification permission on load
    if ('Notification' in window) {
        notificationPermission = Notification.permission;
        if (notificationPermission === 'default') {
            Notification.requestPermission().then(permission => {
                notificationPermission = permission;
            });
        }
    }

    // Create notification sound (simple beep using Web Audio API)
    function playNotificationSound() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioContext = new AudioContext();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = 800;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        } catch (e) {
            console.log('Could not play notification sound:', e);
        }
    }

    // Show desktop notification
    function showDesktopNotification(title, body, icon) {
        if (notificationPermission === 'granted' && 'Notification' in window) {
            try {
                const notification = new Notification(title, {
                    body: body,
                    icon: icon || '/img/kua654ms.png',
                    badge: '/img/kua654ms.png',
                    tag: 'chat-message',
                    requireInteraction: false
                });

                notification.onclick = function() {
                    window.focus();
                    notification.close();
                };

                // Auto close after 5 seconds
                setTimeout(() => notification.close(), 5000);
            } catch (e) {
                console.log('Could not show desktop notification:', e);
            }
        }
    }

    function updateConnectionStatus(status) {
        const statusEl = document.getElementById('connectionStatus');
        statusEl.className = 'connection-status ' + status;
        switch(status) {
            case 'connecting':
                statusEl.textContent = '‚ö†Ô∏è Connecting...';
                break;
            case 'connected':
                statusEl.textContent = '‚úÖ Connected';
                setTimeout(() => statusEl.classList.remove('connected'), 2000);
                break;
            case 'disconnected':
                statusEl.textContent = '‚ùå Connection Lost - Trying to reconnect...';
                break;
        }
        updateConnectionUI();
    }

    function updateConnectionUI() {
        const sendBtn = document.getElementById('sendBtn');
        const messageInput = document.getElementById('messageInput');

        if (!isConnected) {
            sendBtn.disabled = true;
            sendBtn.style.opacity = '0.5';
            sendBtn.style.cursor = 'not-allowed';
            messageInput.placeholder = '‚ö†Ô∏è Disconnected - Reconnecting...';
            messageInput.disabled = true;
        } else {
            sendBtn.disabled = false;
            sendBtn.style.opacity = '1';
            sendBtn.style.cursor = 'pointer';
            messageInput.placeholder = 'Type a message...';
            messageInput.disabled = false;
        }
    }

    function loadConversations() {
        const isSeller = currentUser.userType === 'SELLER';

        return new Promise((resolve, reject) => {
            if (isSeller) {
                // Seller: load existing conversations
                fetch(`/api/conversations/${currentUser.userId}`)
                    .then(res => res.json())
                    .then(convs => {
                        console.log('‚úì Loaded conversations:', convs.length);
                        conversations = convs;
                        renderConversationsList();
                        restoreLastConversation();
                        resolve();
                    })
                    .catch(err => {
                        console.error('Error loading conversations:', err);
                        showToast('‚ùå Failed to load conversations', 'error');
                        reject(err);
                    });
            } else {
                // Customer: load ONLY existing conversations (sellers they've already chatted with)
                fetch(`/api/conversations/${currentUser.userId}`)
                    .then(res => res.json())
                    .then(convs => {
                        console.log('‚úì Loaded conversations for customer:', convs.length);
                        conversations = convs;
                        renderConversationsList();
                        // Don't auto-open any conversation - show welcome screen
                        resolve();
                    })
                    .catch(err => {
                        console.error('Error loading conversations:', err);
                        showToast('‚ùå Failed to load conversations', 'error');
                        reject(err);
                    });
            }
        });
    }

    function renderConversationsList() {
        const list = document.getElementById('conversationsList');
        list.innerHTML = '';

        let totalUnread = 0;

        conversations.forEach(conv => {
            const isCustomer = currentUser.userType === 'CUSTOMER';
            const otherPartyName = isCustomer ? conv.sellerName : conv.customerName;
            const avatar = otherPartyName ? otherPartyName.substring(0, 2).toUpperCase() : '?';

            // Format last message with preview
            let lastMessagePreview = conv.lastMessage || 'Start chatting';
            if (lastMessagePreview.length > 35) {
                lastMessagePreview = lastMessagePreview.substring(0, 35) + '...';
            }

            // Format time
            let timeText = '';
            if (conv.lastMessageTime) {
                timeText = formatRelativeTime(conv.lastMessageTime);
            }

            // Calculate unread
            const unreadCount = conv.unreadCount || 0;
            totalUnread += unreadCount;

            const item = document.createElement('div');
            item.className = 'conversation-item';
            if (currentConversation && currentConversation.id === conv.id) {
                item.classList.add('active');
            }

            // Format unread badge - show "9+" if more than 9
            const unreadBadgeText = unreadCount > 9 ? '9+' : unreadCount;

            item.innerHTML = `
                <div class="avatar ${isCustomer ? 'seller' : ''}">${avatar}</div>
                <div class="conversation-info">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                        <div class="conversation-name">${escapeHtml(otherPartyName)}</div>
                        ${timeText ? `<span style="font-size:11px;color:#6b7280;">${timeText}</span>` : ''}
                    </div>
                    <div class="conversation-last-message" style="display:flex;justify-content:space-between;align-items:center;">
                        <span style="flex:1;">${escapeHtml(lastMessagePreview)}</span>
                        ${unreadCount > 0 ? `<span class="unread-badge" data-conversation-id="${conv.id}">${unreadBadgeText}</span>` : ''}
                    </div>
                </div>
            `;

            item.onclick = () => openConversation(conv);
            list.appendChild(item);
        });

        // Update dashboard unread badges
        updateDashboardUnreadBadge(totalUnread);
    }

    // Update unread count in dashboard
    function updateDashboardUnreadBadge(count) {
        const badge = document.getElementById('unreadChatCount');
        const badgeMenu = document.getElementById('unreadChatCountMenu');

        const displayText = count > 9 ? '9+' : count.toString();

        if (count > 0) {
            if (badge) {
                badge.textContent = displayText;
                badge.style.display = 'inline-flex';
            }
            if (badgeMenu) {
                badgeMenu.textContent = displayText;
                badgeMenu.style.display = 'inline-flex';
            }
        } else {
            if (badge) badge.style.display = 'none';
            if (badgeMenu) badgeMenu.style.display = 'none';
        }
    }

    // Format relative time (e.g., "2m ago", "1h ago", "Yesterday")
    function formatRelativeTime(timestamp) {
        const now = new Date();
        const messageTime = new Date(timestamp);
        const diffMs = now - messageTime;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m`;
        if (diffHours < 24) return `${diffHours}h`;
        if (diffDays === 1) return 'Yesterday';
        if (diffDays < 7) return `${diffDays}d`;

        return messageTime.toLocaleDateString('vi-VN', { month: 'short', day: 'numeric' });
    }

    function markAsRead() {
        if (currentConversation) {
            const csrfToken = document.querySelector('meta[name="_csrf"]')?.content;
            const csrfHeader = document.querySelector('meta[name="_csrf_header"]')?.content;

            const headers = {};
            if (csrfToken && csrfHeader) {
                headers[csrfHeader] = csrfToken;
            }

            fetch(`/api/conversation/${currentConversation.id}/read?userId=${currentUser.userId}`, {
                method: 'POST',
                headers: headers
            }).catch(err => console.error('Error marking as read:', err));
        }
    }

    function renderMessages() {
        const messagesContainer = document.getElementById('chatMessages');

        if (!messagesContainer) {
            console.error('‚ùå Cannot render messages: messagesContainer not found');
            return;
        }

        messagesContainer.innerHTML = '';

        console.log('üì® Rendering messages for conversation:', currentConversation?.id);
        console.log('   Messages count:', currentConversation?.messages?.length || 0);

        if (currentConversation && currentConversation.messages) {
            currentConversation.messages.forEach(msg => {
                console.log('   - Message:', msg.id, msg.content?.substring(0, 30));
                displayMessage(msg, false);
            });
        }
        scrollToBottom();
    }
    function displayMessage(message, shouldScroll = true) {
        const messagesContainer = document.getElementById('chatMessages');

        if (!messagesContainer) {
            console.error('‚ùå messagesContainer not found!');
            return;
        }

        const isSent = message.senderId === currentUser.userId;
        const isDeleted = message.deleted || false;

        const messageWrapper = document.createElement('div');
        messageWrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
        messageWrapper.setAttribute('data-message-id', message.id);

        const avatarClass = message.senderRole === 'SELLER' ? 'seller' : '';
        const avatar = message.senderName ? message.senderName.substring(0, 2).toUpperCase() : '?';

        // Build reply quote if message is a reply
        let replyQuoteHtml = '';
        if (message.replyToMessageId && message.replyToContent) {
            replyQuoteHtml = `
                <div class="message-reply-quote" onclick="scrollToMessage('${message.replyToMessageId}')">
                    <div class="reply-quote-sender">${escapeHtml(message.replyToSenderName || 'User')}</div>
                    <div class="reply-quote-content">${escapeHtml(message.replyToContent.substring(0, 50))}${message.replyToContent.length > 50 ? '...' : ''}</div>
                </div>
            `;
        }

        // Build message content based on type
        let messageContent = '';

        if (isDeleted) {
            // Deleted message
            messageContent = `
                <div class="message-bubble deleted">
                    This message has been deleted
                    <span class="deleted-message-icon" onclick="permanentlyDeleteMessage('${message.id}')">üóëÔ∏è</span>
                </div>
            `;
        } else if (message.messageType === 'IMAGE' && message.fileUrl) {
            // Image message
            messageContent = `
                <div class="message-bubble">
                    ${replyQuoteHtml}
                    ${message.content ? `<div style="margin-bottom: 8px;">${escapeHtml(message.content)}</div>` : ''}
                    <img src="${message.fileUrl}" alt="${escapeHtml(message.fileName || 'Image')}"
                         style="max-width: 300px; max-height: 300px; border-radius: 8px; cursor: pointer;"
                         onclick="window.open('${message.fileUrl}', '_blank')">
                </div>
            `;
        } else if (message.messageType === 'FILE' && message.fileUrl) {
            // File attachment message
            const fileSize = message.fileSize ? (message.fileSize / 1024).toFixed(1) + ' KB' : '';
            messageContent = `
                <div class="message-bubble">
                    ${replyQuoteHtml}
                    ${message.content ? `<div style="margin-bottom: 8px;">${escapeHtml(message.content)}</div>` : ''}
                    <a href="${message.fileUrl}" target="_blank" download
                       style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(0,0,0,0.05); border-radius: 8px; text-decoration: none; color: inherit;">
                        <span style="font-size: 32px;">üìé</span>
                        <div>
                            <div style="font-weight: 600;">${escapeHtml(message.fileName || 'File')}</div>
                            ${fileSize ? `<div style="font-size: 12px; opacity: 0.7;">${fileSize}</div>` : ''}
                        </div>
                        <span style="font-size: 20px; margin-left: auto;">‚¨áÔ∏è</span>
                    </a>
                </div>
            `;
        } else {
            // Text message
            messageContent = `
                <div class="message-bubble">
                    ${replyQuoteHtml}
                    ${escapeHtml(message.content)}
                </div>
            `;
        }

        // Build reactions display
        let reactionsHtml = '';
        if (message.reactions && Object.keys(message.reactions).length > 0) {
            // Calculate total reactions and find most popular emoji
            let totalReactions = 0;
            let mostPopularEmoji = '';
            let maxCount = 0;

            for (const [emoji, users] of Object.entries(message.reactions)) {
                totalReactions += users.length;
                if (users.length > maxCount) {
                    maxCount = users.length;
                    mostPopularEmoji = emoji;
                }
            }

            const emojiCount = Object.keys(message.reactions).length;
            const displayCount = emojiCount === 1 ? totalReactions : totalReactions + '+';

            // Check if current user reacted to any emoji
            const userIdStr = String(currentUser.userId);
            let userReacted = false;
            for (const users of Object.values(message.reactions)) {
                if (users.some(id => String(id) === userIdStr)) {
                    userReacted = true;
                    break;
                }
            }
            const userClass = userReacted ? 'user-reacted' : '';

            reactionsHtml = `
                <div class="message-reactions">
                    <div class="reaction-badge-compact ${userClass}" onclick="showReactionDetails('${message.id}')" title="Xem chi ti·∫øt reactions">
                        <span class="reaction-emoji">${mostPopularEmoji}</span>
                        <span class="reaction-count">${displayCount}</span>
                    </div>
                </div>
            `;
        }

        // Build message actions toolbar (only if not deleted)
        let actionsHtml = '';
        if (!isDeleted) {
            actionsHtml = `
                <div class="message-actions">
                    <button class="message-action-btn emoji-btn" onclick="showReactionPicker('${message.id}')" title="React">
                        üòä
                    </button>
                    <button class="message-action-btn reply-btn" onclick="replyToMessage('${message.id}', '${escapeHtml(message.senderName)}', '${escapeHtml(message.content.substring(0, 50))}')" title="Reply">
                        ‚Ü©Ô∏è
                    </button>
                    ${isSent ? `<button class="message-action-btn delete-btn" onclick="deleteMessage('${message.id}')" title="Delete">üóëÔ∏è</button>` : ''}
                </div>
            `;
        }

        messageWrapper.innerHTML = `
            <div class="message ${isSent ? 'sent' : 'received'}">
                <div class="message-avatar ${avatarClass}">${avatar}</div>
                <div class="message-content">
                    ${messageContent}
                    ${reactionsHtml}
                    <div class="message-time">${formatTime(message.timestamp || message.createdAt)}</div>
                </div>
            </div>
            ${actionsHtml}
        `;

        messagesContainer.appendChild(messageWrapper);

        if (shouldScroll) {
            scrollToBottom();
        }

        console.log('‚úÖ Displayed message:', message.id, 'from:', message.senderName);
    }


    function updateMessageStatus(tempId, status) {
        const msgElement = document.querySelector(`[data-temp-id="${tempId}"]`);
        if (msgElement) {
            const statusSpan = msgElement.querySelector('.message-status');
            if (statusSpan) {
                switch(status) {
                    case 'sending':
                        statusSpan.textContent = '‚óã';
                        statusSpan.title = 'Sending...';
                        break;
                    case 'sent':
                        statusSpan.textContent = '‚úì';
                        statusSpan.title = 'Sent';
                        break;
                    case 'queued':
                        statusSpan.textContent = '‚è≥';
                        statusSpan.title = 'Queued';
                        break;
                }
            }
        }
    }

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }

    function scrollToBottom() {
        const messagesContainer = document.getElementById('chatMessages');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatTime(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;

        if (diff < 60000) return 'Just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
        if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
        return date.toLocaleDateString();
    }

    function updateCharCount() {
        const input = document.getElementById('messageInput');
        const charCount = document.getElementById('charCount');
        const length = input.value.length;

        if (length > 0) {
            charCount.style.display = 'inline';
            charCount.textContent = `${length}/${MAX_MESSAGE_LENGTH}`;

            if (length > MAX_MESSAGE_LENGTH * 0.9) {
                charCount.style.color = 'orange';
            } else {
                charCount.style.color = '#999';
            }
        } else {
            charCount.style.display = 'none';
        }
    }

    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            bottom: 80px;
            right: 20px;
            padding: 12px 20px;
            background: ${type === 'warning' ? '#ffc107' : type === 'error' ? '#dc3545' : type === 'info' ? '#17a2b8' : '#28a745'};
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 9999;
            font-size: 14px;
            max-width: 300px;
            animation: slideIn 0.3s ease;
        `;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    function restoreLastConversation() {
        const lastConvId = localStorage.getItem(LAST_CONVERSATION_KEY);
        if (lastConvId && !targetConversationId && !targetSellerId) {
            const conv = conversations.find(c => c.id === lastConvId);
            if (conv) {
                openConversation(conv);
            }
        }
    }

    // Initialize
    connect();
    loadConversations().then(() => {
        // Remove loading state after conversations are loaded
        setTimeout(() => {
            document.body.classList.remove('loading');
        }, 500);
    }).catch(() => {
        // Remove loading state even if there's an error
        document.body.classList.remove('loading');
    });

    // Auto-open conversation if conversationId is provided
    const targetConversationId = /*[[${conversationId}]]*/ null;
    const targetSellerId = /*[[${targetSellerId}]]*/ null;
    const productId = /*[[${productId}]]*/ null;
    const productName = /*[[${productName}]]*/ null;
    const productPrice = /*[[${productPrice}]]*/ null;

    if (targetConversationId) {
        // Wait for conversations to load, then open the target conversation
        const checkAndOpen = setInterval(() => {
            const conv = conversations.find(c => c.id === targetConversationId);
            if (conv) {
                clearInterval(checkAndOpen);
                openConversation(conv);

                // Auto-send product info message if product context is available
                if (productId && productName && productPrice) {
                    setTimeout(() => {
                        sendProductInfoMessage(productId, productName, productPrice);
                    }, 1000);
                }
            }
        }, 500);

        // Clear interval after 10 seconds to prevent infinite loop
        setTimeout(() => {
            clearInterval(checkAndOpen);
            if (!currentConversation) {
                showToast('‚ö†Ô∏è Could not open conversation automatically', 'warning');
            }
        }, 10000);
    } else if (targetSellerId && currentUser.userType === 'CUSTOMER') {
        // For customer: if sellerId is provided, create/open conversation with that seller
        console.log('Creating conversation with seller:', targetSellerId);
        console.log('Customer ID:', currentUser.userId);

        // Get CSRF token
        const csrfToken = document.querySelector('meta[name="_csrf"]')?.content;
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]')?.content;

        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
        };

        if (csrfToken && csrfHeader) {
            headers[csrfHeader] = csrfToken;
        }

        fetch('/api/conversation', {
            method: 'POST',
            headers: headers,
            body: `customerId=${currentUser.userId}&sellerId=${targetSellerId}`
        })
            .then(response => {
                console.log('Response status:', response.status);
                if (!response.ok) {
                    return response.json().then(err => {
                        console.error('Error response:', err);
                        throw new Error(err.error || 'Failed to create conversation');
                    });
                }
                return response.json();
            })
            .then(conversation => {
                console.log('Conversation created:', conversation);
                // Reload conversations to include the new one
                loadConversations().then(() => {
                    const conv = conversations.find(c => c.id === conversation.id);
                    if (conv) {
                        openConversation(conv);

                        // Auto-send product info message if product context is available
                        if (productId && productName && productPrice) {
                            setTimeout(() => {
                                sendProductInfoMessage(productId, productName, productPrice);
                            }, 1000);
                        }
                    } else {
                        showToast('‚ö†Ô∏è Conversation created but could not open', 'warning');
                    }
                });
            })
            .catch(error => {
                console.error('Error creating conversation:', error);

                // Show more specific error message
                let errorMsg = 'Cannot start chat';
                if (error.message.includes('not a seller')) {
                    errorMsg = 'This user is not a seller';
                } else if (error.message.includes('not found')) {
                    errorMsg = 'Seller not found';
                } else if (error.message) {
                    errorMsg = error.message;
                }

                showToast(`‚ùå ${errorMsg}`, 'error');

                // Redirect back after 3 seconds
                setTimeout(() => {
                    window.location.href = document.referrer || '/customer/dashboard';
                }, 3000);
            });
    }

    // Function to send product info message
    function sendProductInfoMessage(prodId, prodName, prodPrice) {
        if (!currentConversation || !isConnected) {
            console.warn('Cannot send product info: no conversation or not connected');
            return;
        }

        const formattedPrice = new Intl.NumberFormat('vi-VN', {
            style: 'currency',
            currency: 'VND'
        }).format(prodPrice);

        const productLink = window.location.origin + '/product/' + prodId;
        // const messageContent = `üëã Xin ch√†o! T√¥i mu·ªën h·ªèi v·ªÅ s·∫£n ph·∫©m n√†y:\n\nüì¶ ${prodName}\nüí∞ Gi√°: ${formattedPrice}\nüîó ${productLink}`;

        const message = {
            id: 'temp_product_' + Date.now(),
            conversationId: currentConversation.id,
            senderId: currentUser.userId,
            senderName: currentUser.fullName || currentUser.username,
            senderRole: currentUser.userType,
            receiverId: currentConversation.sellerId,
            content: messageContent,
            type: 'TEXT',
            read: false,
            status: 'sending'
        };

        // Display message
        displayMessage(message);
        scrollToBottom();

        // Send via WebSocket
        if (isConnected) {
            stompClient.send('/app/sendMessage', {}, JSON.stringify(message));
            setTimeout(() => {
                updateMessageStatus(message.id, 'sent');
            }, 500);
        }
    }

    window.onbeforeunload = function() {
        if (stompClient && isConnected) {
            stompClient.send('/app/user.disconnect', {}, JSON.stringify({
                userId: currentUser.userId
            }));
            stompClient.disconnect();
        }
    };

    function processMessageQueue() {
        if (messageQueue.length > 0) {
            showToast(`üì§ Sending ${messageQueue.length} queued message${messageQueue.length > 1 ? 's' : ''}...`, 'info');
            const queueCopy = [...messageQueue];
            messageQueue = [];

            queueCopy.forEach(msg => {
                setTimeout(() => {
                    stompClient.send('/app/sendMessage', {}, JSON.stringify(msg));
                }, 100);
            });
        }
    }

    function handleNotification(notification) {
        if (notification.type === 'NEW_MESSAGE') {
            // Reload conversations to update unread counts
            loadConversations();

            // Play sound for new messages from others
            if (notification.senderId !== currentUser.userId) {
                playNotificationSound();

                if (!document.hasFocus()) {
                    showDesktopNotification(
                        `üí¨ New message from ${notification.senderName}`,
                        notification.messagePreview
                    );
                }
            }
        }
    }

    function updateUserStatus(status) {
        // Update UI to show online/offline status
        const conversationItems = document.querySelectorAll('.conversation-item');
        conversationItems.forEach(item => {
            // You can implement online status indicators here
        });
    }

    function connect() {
        if (isConnected) return;
        updateConnectionStatus('connecting');

        // S·ª¨A ENDPOINT TH√ÄNH /ws-chat
        const socket = new SockJS('/ws-chat');
        stompClient = Stomp.over(socket);
        stompClient.debug = null; // T·∫Øt debug ƒë·ªÉ ƒë·ª° r·ªëi console

        stompClient.connect(
            { userId: currentUser.userId },
            function(frame) {
                console.log('‚úÖ WebSocket Connected:', frame);
                isConnected = true;
                updateConnectionStatus('connected');
                document.body.classList.remove('loading');

                // Subscribe to conversation topics
                if (currentConversation) {
                    subscribeToConversation(currentConversation.id);
                }

                // Subscribe to user notifications
                subscriptions.notifications = stompClient.subscribe(
                    '/topic/user/' + currentUser.userId + '/messages',
                    function(message) {
                        console.log('üì® Received message notification');
                        const msg = JSON.parse(message.body);
                        handleNewMessage(msg);
                    }
                );

                // Notify server that user is online
                stompClient.send('/app/chat.userOnline', {}, JSON.stringify({
                    userId: currentUser.userId
                }));

                console.log('‚úÖ All subscriptions active');

            },
            function(error) {
                console.error('‚ùå WebSocket connection error:', error);
                isConnected = false;
                updateConnectionStatus('disconnected');
                document.body.classList.remove('loading');

                // Auto-reconnect after 3 seconds
                setTimeout(connect, 3000);
            }
        );
    }

    function subscribeToConversation(conversationId) {
        if (subscriptions.conversation) {
            subscriptions.conversation.unsubscribe();
        }

        subscriptions.conversation = stompClient.subscribe(
            '/topic/conversation/' + conversationId,
            function(message) {
                console.log('üí¨ Received conversation message');
                const msg = JSON.parse(message.body);

                // üö® HI·ªÇN TH·ªä T·∫§T C·∫¢ tin nh·∫Øn, nh∆∞ng x·ª≠ l√Ω duplicate
                handleIncomingMessage(msg);
            }
        );

        console.log('‚úÖ Subscribed to conversation: ' + conversationId);
    }

    // üö® H√†m m·ªõi ƒë·ªÉ x·ª≠ l√Ω tin nh·∫Øn ƒë·∫øn
    function handleIncomingMessage(msg) {
        console.log('üÜï Incoming message ID:', msg.id, 'from:', msg.senderId);

        // Ki·ªÉm tra xem tin nh·∫Øn ƒë√£ t·ªìn t·∫°i ch∆∞a
        const existingMessage = document.querySelector(`[data-message-id="${msg.id}"]`);
        if (existingMessage) {
            console.log('üîÑ Message already exists, skipping');
            return;
        }

        // Ki·ªÉm tra temp message (tin nh·∫Øn c·ªßa ch√≠nh m√¨nh)
        const tempMessages = document.querySelectorAll('[data-message-id^="temp_"]');
        if (msg.senderId === currentUser.userId && tempMessages.length > 0) {
            console.log('üîÑ Replacing temp message with real one');
            // X√≥a temp message v√† hi·ªÉn th·ªã real message
            tempMessages.forEach(tempMsg => tempMsg.remove());
        }

        // Hi·ªÉn th·ªã tin nh·∫Øn
        displayMessage(msg, true);

        // Th√¥ng b√°o cho tin nh·∫Øn t·ª´ ng∆∞·ªùi kh√°c
        if (msg.senderId !== currentUser.userId) {
            playNotificationSound();
            if (!document.hasFocus()) {
                showDesktopNotification(
                    `üí¨ New message from ${msg.senderName}`,
                    msg.content.length > 50 ? msg.content.substring(0, 50) + '...' : msg.content
                );
            }
        }

        // Reload conversations ƒë·ªÉ update unread counts
        loadConversations();
    }

    function sendMessage() {
        const input = document.getElementById('messageInput');
        const content = input.value.trim();

        if (!content || !currentConversation) {
            console.log('‚ùå Cannot send: no content or conversation');
            return;
        }

        console.log('üì§ Sending message:', content);

        const tempId = 'temp_' + Date.now();
        const messageData = {
            conversationId: currentConversation.id,
            senderId: currentUser.userId,
            senderName: currentUser.fullName || currentUser.username,
            senderRole: currentUser.userType,
            receiverId: currentUser.userType === 'CUSTOMER' ? currentConversation.sellerId : currentConversation.customerId,
            content: content,
            messageType: 'TEXT'
        };

        // üö® B·∫¨T L·∫†I optimistic UI - nh∆∞ng v·ªõi tempId ƒë·ªÉ tr√°nh duplicate
        const tempMessage = {
            id: tempId,
            ...messageData,
            read: false,
            createdAt: new Date().toISOString(),
            timestamp: new Date().toISOString()
        };

        displayMessage(tempMessage, true);
        input.value = '';
        updateCharCount();

        // Send via WebSocket
        if (isConnected) {
            stompClient.send('/app/chat.sendMessage', {}, JSON.stringify(messageData));
            console.log('‚úÖ Message sent via WebSocket with tempId:', tempId);
        } else {
            messageQueue.push(messageData);
            showToast('‚ö†Ô∏è Offline - Message queued', 'warning');
            console.log('‚ö†Ô∏è Message queued (offline)');
        }
    }

    function openConversation(conv) {
        console.log('üí¨ Opening conversation:', conv.id);

        if (currentConversation && subscriptions.conversation) {
            subscriptions.conversation.unsubscribe();
        }

        currentConversation = conv;
        localStorage.setItem(LAST_CONVERSATION_KEY, conv.id);

        // Hide welcome screen and show chat area
        document.getElementById('welcomeScreen').style.display = 'none';
        const chatArea = document.getElementById('chatArea');
        chatArea.classList.remove('hidden');
        chatArea.style.removeProperty('display'); // Remove the !important
        chatArea.style.display = 'flex';

        const isCustomer = currentUser.userType === 'CUSTOMER';
        const otherPartyName = isCustomer ? conv.sellerName : conv.customerName;
        const avatar = otherPartyName ? otherPartyName.substring(0, 2).toUpperCase() : '?';

        document.getElementById('chatHeaderName').textContent = otherPartyName;
        document.getElementById('chatHeaderAvatar').textContent = avatar;
        document.getElementById('chatHeaderAvatar').className = `avatar ${isCustomer ? 'seller' : ''}`;

        // Subscribe to conversation
        if (stompClient && isConnected) {
            subscribeToConversation(conv.id);
        }

        // Render messages and mark as read
        renderMessages();
        markAsRead();

        // Hide unread badge for this conversation
        const badge = document.querySelector(`.unread-badge[data-conversation-id="${conv.id}"]`);
        if (badge) {
            badge.style.display = 'none';

            // Update total unread count in dashboard
            const currentUnread = parseInt(badge.textContent.replace('+', '')) || 0;
            const dashboardBadge = document.getElementById('unreadChatCount');
            if (dashboardBadge && dashboardBadge.style.display !== 'none') {
                const totalUnread = parseInt(dashboardBadge.textContent.replace('+', '')) || 0;
                const newTotal = Math.max(0, totalUnread - currentUnread);
                updateDashboardUnreadBadge(newTotal);
            }
        }

        // Focus input
        setTimeout(() => {
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.focus();
            }
        }, 100);
    }

    function handleNewMessage(msg) {
        console.log('üÜï Handling new message from:', msg.senderName);

        // Only process if not from current user (to avoid duplicates)
        if (msg.senderId !== currentUser.userId) {
            playNotificationSound();

            if (!document.hasFocus()) {
                showDesktopNotification(
                    `üí¨ New message from ${msg.senderName}`,
                    msg.content.length > 50 ? msg.content.substring(0, 50) + '...' : msg.content
                );
            }
        }

        // If this message belongs to current conversation, display it
        if (currentConversation && msg.conversationId === currentConversation.id) {
            displayMessage(msg);
            // Mark as read immediately if conversation is open
            markAsRead();
        } else {
            // Update unread count for other conversations
            loadConversations();
        }
    }

    // ===== CHAT FEATURES FUNCTIONS =====

    let currentUploadFile = null;
    let recentEmojis = localStorage.getItem('recentEmojis') ? JSON.parse(localStorage.getItem('recentEmojis')) : [];

    // Emoji data
    const emojiData = {
        smileys: ['üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','ü§£','üòÇ','üôÇ','üôÉ','üòâ','üòä','üòá','ü•∞','üòç','ü§©','üòò','üòó','‚ò∫Ô∏è','üòö','üòô','ü•≤','üòã','üòõ','üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§ê','ü§®','üòê','üòë','üò∂','üòè','üòí','üôÑ','üò¨','ü§•','üòå','üòî','üò™','ü§§','üò¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','ü•µ','ü•∂','ü•¥','üòµ','ü§Ø','ü§†','ü•≥','ü•∏','üòé','ü§ì','üßê'],
        gestures: ['üëã','ü§ö','üñêÔ∏è','‚úã','üññ','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û','ü§ü','ü§ò','ü§ô','üëà','üëâ','üëÜ','üñï','üëá','‚òùÔ∏è','üëç','üëé','‚úä','üëä','ü§õ','ü§ú','üëè','üôå','üëê','ü§≤','ü§ù','üôè','‚úçÔ∏è','üí™','ü¶æ','ü¶ø','ü¶µ','ü¶∂','üëÇ','ü¶ª','üëÉ','üß†','ü´Ä','ü´Å','ü¶∑','ü¶¥','üëÄ','üëÅÔ∏è','üëÖ','üëÑ','üíã'],
        objects: ['üéÅ','üéà','üéâ','üéä','üéÄ','üéÇ','üéÑ','üéÉ','üéÜ','üéá','üß®','‚ú®','üéã','üéç','üéë','üéè','üéê','üßß','üì±','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üíæ','üíø','üìÄ','üì∑','üì∏','üìπ','üé•','üìû','‚òéÔ∏è','üìü','üì†','üì∫','üìª','üéôÔ∏è','üéöÔ∏è','üéõÔ∏è','üß≠','‚è±Ô∏è','‚è∞','‚è≤Ô∏è','‚åö','üì°','üîã','üîå','üí°','üî¶','üïØÔ∏è']
    };

    function toggleFeaturesMenu() {
        const menu = document.getElementById('featuresMenu');
        const emojiPicker = document.getElementById('emojiPicker');

        menu.classList.toggle('show');
        emojiPicker.classList.remove('show');
    }

    function toggleEmojiPicker() {
        const emojiPicker = document.getElementById('emojiPicker');
        const featuresMenu = document.getElementById('featuresMenu');

        emojiPicker.classList.toggle('show');
        featuresMenu.classList.remove('show');

        if (emojiPicker.classList.contains('show')) {
            loadEmojis('smileys');
        }
    }

    function closeEmojiPicker() {
        document.getElementById('emojiPicker').classList.remove('show');
    }

    function loadEmojis(category) {
        const emojiGrid = document.getElementById('emojiGrid');
        let emojis = [];

        if (category === 'recent') {
            emojis = recentEmojis.length > 0 ? recentEmojis : emojiData.smileys.slice(0, 24);
        } else {
            emojis = emojiData[category] || [];
        }

        emojiGrid.innerHTML = '';
        emojis.forEach(emoji => {
            const btn = document.createElement('button');
            btn.className = 'emoji-item';
            btn.textContent = emoji;
            btn.onclick = () => insertEmoji(emoji);
            emojiGrid.appendChild(btn);
        });

        // Update active category button
        document.querySelectorAll('.emoji-category-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.category === category) {
                btn.classList.add('active');
            }
        });
    }

    function insertEmoji(emoji) {
        const input = document.getElementById('messageInput');
        const cursorPos = input.selectionStart;
        const textBefore = input.value.substring(0, cursorPos);
        const textAfter = input.value.substring(cursorPos);

        input.value = textBefore + emoji + textAfter;
        input.focus();
        input.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);

        updateCharCount();

        // Add to recent emojis
        if (!recentEmojis.includes(emoji)) {
            recentEmojis.unshift(emoji);
            if (recentEmojis.length > 24) {
                recentEmojis = recentEmojis.slice(0, 24);
            }
            localStorage.setItem('recentEmojis', JSON.stringify(recentEmojis));
        }
    }

    // Setup emoji category buttons
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.emoji-category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                loadEmojis(btn.dataset.category);
            });
        });

        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            const featuresMenu = document.getElementById('featuresMenu');
            const emojiPicker = document.getElementById('emojiPicker');
            const btnPlus = document.getElementById('btnPlus');

            if (!featuresMenu.contains(e.target) &&
                !emojiPicker.contains(e.target) &&
                e.target !== btnPlus &&
                !btnPlus.contains(e.target)) {
                featuresMenu.classList.remove('show');
                emojiPicker.classList.remove('show');
            }
        });
    });

    function openImageUpload() {
        document.getElementById('imageInput').click();
        document.getElementById('featuresMenu').classList.remove('show');
    }

    function openFileUpload() {
        document.getElementById('fileInput').click();
        document.getElementById('featuresMenu').classList.remove('show');
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.startsWith('image/')) {
            showToast('‚ùå Vui l√≤ng ch·ªçn file ·∫£nh', 'error');
            return;
        }

        if (file.size > 5 * 1024 * 1024) { // 5MB limit
            showToast('‚ùå K√≠ch th∆∞·ªõc ·∫£nh ph·∫£i nh·ªè h∆°n 5MB', 'error');
            return;
        }

        currentUploadFile = file;

        const reader = new FileReader();
        reader.onload = (e) => {
            const preview = document.getElementById('uploadPreview');
            const previewImage = document.getElementById('previewImage');
            const previewInfo = document.getElementById('previewInfo');

            previewImage.src = e.target.result;
            previewImage.style.display = 'block';
            previewInfo.innerHTML = `
                <div style="font-weight: 600;">${file.name}</div>
                <div style="color: var(--muted, #6b7280); margin-top: 4px;">
                    ${(file.size / 1024).toFixed(1)} KB
                </div>
            `;
            preview.classList.add('show');

            showToast('üì∏ ·∫¢nh ƒë√£ s·∫µn s√†ng ƒë·ªÉ g·ª≠i', 'info');
        };
        reader.readAsDataURL(file);

        // Clear input to allow same file selection
        event.target.value = '';
    }

    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (file.size > 10 * 1024 * 1024) { // 10MB limit
            showToast('‚ùå K√≠ch th∆∞·ªõc file ph·∫£i nh·ªè h∆°n 10MB', 'error');
            return;
        }

        currentUploadFile = file;

        const preview = document.getElementById('uploadPreview');
        const previewImage = document.getElementById('previewImage');
        const previewInfo = document.getElementById('previewInfo');

        previewImage.style.display = 'none';

        const fileIcon = getFileIcon(file.name);
        previewInfo.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 24px;">${fileIcon}</span>
                <div>
                    <div style="font-weight: 600;">${file.name}</div>
                    <div style="color: var(--muted, #6b7280); margin-top: 4px;">
                        ${(file.size / 1024).toFixed(1)} KB
                    </div>
                </div>
            </div>
        `;
        preview.classList.add('show');

        showToast('üìé File ƒë√£ s·∫µn s√†ng ƒë·ªÉ g·ª≠i', 'info');

        // Clear input
        event.target.value = '';
    }

    function getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const iconMap = {
            'pdf': 'üìÑ',
            'doc': 'üìù',
            'docx': 'üìù',
            'txt': 'üìÉ',
            'zip': 'üóúÔ∏è',
            'rar': 'üóúÔ∏è'
        };
        return iconMap[ext] || 'üìé';
    }

    function clearUpload() {
        currentUploadFile = null;
        const preview = document.getElementById('uploadPreview');
        preview.classList.remove('show');
        document.getElementById('previewImage').src = '';
        document.getElementById('previewInfo').innerHTML = '';
        showToast('üóëÔ∏è ƒê√£ x√≥a file', 'info');
    }

    // Upload file to server
    async function uploadFileToServer(file, type) {
        const formData = new FormData();
        formData.append('file', file);

        const csrfToken = document.querySelector('meta[name="_csrf"]')?.content;
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]')?.content;

        const headers = {};
        if (csrfToken && csrfHeader) {
            headers[csrfHeader] = csrfToken;
        }

        try {
            const endpoint = type === 'image' ? '/api/upload/image' : '/api/upload/file';
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: headers,
                body: formData
            });

            if (!response.ok) {
                throw new Error('Upload failed');
            }

            return await response.json();
        } catch (error) {
            console.error('Upload error:', error);
            throw error;
        }
    }

    // Wrap original sendMessage to handle file uploads
    const originalSendMessage = sendMessage;
    sendMessage = async function() {
        const input = document.getElementById('messageInput');
        const content = input.value.trim();

        // Check if we have file to upload
        if (currentUploadFile) {
            showToast('üì§ ƒêang t·∫£i file l√™n...', 'info');

            try {
                // Determine file type
                const isImage = currentUploadFile.type.startsWith('image/');
                const uploadType = isImage ? 'image' : 'file';

                // Upload file
                const uploadResult = await uploadFileToServer(currentUploadFile, uploadType);

                if (!uploadResult.success) {
                    throw new Error(uploadResult.error || 'Upload failed');
                }

                // Create message with file attachment
                const messageData = {
                    conversationId: currentConversation.id,
                    senderId: currentUser.userId,
                    senderName: currentUser.fullName || currentUser.username,
                    senderRole: currentUser.userType,
                    receiverId: currentUser.userType === 'CUSTOMER' ? currentConversation.sellerId : currentConversation.customerId,
                    content: content || `[${isImage ? 'üñºÔ∏è ·∫¢nh' : 'üìé File'}] ${currentUploadFile.name}`,
                    messageType: isImage ? 'IMAGE' : 'FILE',
                    fileUrl: uploadResult.fileUrl,
                    fileName: uploadResult.filename,
                    fileType: uploadType,
                    fileSize: uploadResult.size
                };

                // Send message via WebSocket
                if (isConnected) {
                    stompClient.send('/app/chat.sendMessage', {}, JSON.stringify(messageData));
                    showToast('‚úÖ ƒê√£ g·ª≠i ' + (isImage ? '·∫£nh' : 'file'), 'success');
                } else {
                    messageQueue.push(messageData);
                    showToast('‚ö†Ô∏è Offline - Message queued', 'warning');
                }

                // Clear upload and input
                clearUpload();
                input.value = '';
                updateCharCount();

            } catch (error) {
                console.error('Send file error:', error);
                showToast('‚ùå Kh√¥ng th·ªÉ g·ª≠i file: ' + error.message, 'error');
            }

            return;
        }

        // Normal text message - call original function
        originalSendMessage();
    };

    // ===== ENHANCED CHAT FEATURES =====

    let currentReplyTo = null;
    let currentReactionPicker = null;

    // Available reactions
    const REACTIONS = ['‚ù§Ô∏è', 'üòÇ', 'üò¢', 'üò°', 'üòÆ', 'üëç'];

    // Show reaction picker for a message
    function showReactionPicker(messageId) {
        // Close any existing picker
        if (currentReactionPicker) {
            currentReactionPicker.remove();
            currentReactionPicker = null;
        }

        const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
        if (!messageWrapper) return;

        const picker = document.createElement('div');
        picker.className = 'reaction-picker show';
        picker.innerHTML = REACTIONS.map(emoji =>
            `<button class="reaction-option" onclick="addReaction('${messageId}', '${emoji}')">${emoji}</button>`
        ).join('');

        messageWrapper.style.position = 'relative';
        messageWrapper.appendChild(picker);
        currentReactionPicker = picker;

        // Close picker when clicking outside
        setTimeout(() => {
            document.addEventListener('click', closeReactionPickerHandler);
        }, 100);
    }

    function closeReactionPickerHandler(e) {
        if (currentReactionPicker && !currentReactionPicker.contains(e.target) &&
            !e.target.classList.contains('emoji-btn')) {
            currentReactionPicker.remove();
            currentReactionPicker = null;
            document.removeEventListener('click', closeReactionPickerHandler);
        }
    }

    // Add reaction to a message
    function addReaction(messageId, emoji) {
        console.log('üéØ addReaction called:', { messageId, emoji, userId: currentUser.userId });

        if (!currentConversation || !isConnected) {
            showToast('‚ö†Ô∏è Cannot add reaction: not connected', 'warning');
            return;
        }

        // üöÄ OPTIMISTIC UPDATE - Update UI immediately
        // Convert messageId to String for comparison (message.id from DB could be Number or String)
        const messageIdStr = String(messageId);
        const message = currentConversation?.messages.find(m => String(m.id) === messageIdStr);
        console.log('üìù Looking for message:', messageIdStr, 'Found:', message ? 'YES' : 'NO', message?.id);

        if (!message) {
            console.error('‚ùå Message not found. All message IDs:', currentConversation?.messages.map(m => m.id));
        }

        if (message) {
            if (!message.reactions) {
                message.reactions = {};
            }
            if (!message.reactions[emoji]) {
                message.reactions[emoji] = [];
            }

            // Convert userId to string to ensure matching
            const userIdStr = String(currentUser.userId);

            if (!message.reactions[emoji].includes(userIdStr)) {
                message.reactions[emoji].push(userIdStr);
                console.log('‚úÖ Updated reactions locally:', message.reactions);

                // üîß UPDATE IN-PLACE instead of remove/append to keep message position
                const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
                console.log('üîç Found messageWrapper:', messageWrapper ? 'YES' : 'NO');

                if (messageWrapper) {
                    // Update only the reactions section, not the entire message
                    updateReactionsDisplay(messageWrapper, message);
                    console.log('üé® Updated reactions in-place (position preserved)');
                }
            } else {
                console.log('‚ö†Ô∏è User already reacted with this emoji');
            }
        } else {
            console.error('‚ùå Message not found:', messageId);
        }

        const reactionData = {
            messageId: messageId,
            userId: String(currentUser.userId),
            userName: currentUser.fullName || currentUser.username,
            emoji: emoji,
            conversationId: currentConversation.id
        };

        console.log('üì§ Sending reaction to server:', reactionData);

        // Send reaction via WebSocket
        stompClient.send('/app/chat.addReaction', {}, JSON.stringify(reactionData));

        // Close picker
        if (currentReactionPicker) {
            currentReactionPicker.remove();
            currentReactionPicker = null;
        }

        console.log('‚úÖ Added reaction:', emoji, 'to message:', messageId);
    }

    // Remove reaction from a message
    function removeReaction(messageId, emoji) {
        console.log('üéØ removeReaction called:', { messageId, emoji, userId: currentUser.userId });

        if (!currentConversation || !isConnected) {
            showToast('‚ö†Ô∏è Cannot remove reaction: not connected', 'warning');
            return;
        }

        // üöÄ OPTIMISTIC UPDATE - Update UI immediately
        // Convert messageId to String for comparison
        const messageIdStr = String(messageId);
        const message = currentConversation?.messages.find(m => String(m.id) === messageIdStr);
        const userIdStr = String(currentUser.userId);

        if (message && message.reactions && message.reactions[emoji]) {
            message.reactions[emoji] = message.reactions[emoji].filter(id => String(id) !== userIdStr);
            if (message.reactions[emoji].length === 0) {
                delete message.reactions[emoji];
            }

            console.log('‚úÖ Removed reaction locally:', message.reactions);

            // üîß UPDATE IN-PLACE to preserve message position
            const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageWrapper) {
                updateReactionsDisplay(messageWrapper, message);
                console.log('üé® Updated reactions in-place after removal');
            }
        }

        const reactionData = {
            messageId: messageId,
            userId: String(currentUser.userId),
            emoji: emoji,
            conversationId: currentConversation.id
        };

        console.log('üì§ Sending remove reaction to server:', reactionData);

        // Send remove reaction via WebSocket
        stompClient.send('/app/chat.removeReaction', {}, JSON.stringify(reactionData));

        console.log('‚úÖ Removed reaction:', emoji, 'from message:', messageId);
    }

    // Helper function to update reactions display in-place without re-rendering entire message
    function updateReactionsDisplay(messageWrapper, message) {
        // Find or create reactions container
        const messageContent = messageWrapper.querySelector('.message-content');
        if (!messageContent) return;

        // Remove existing reactions if any
        const existingReactions = messageContent.querySelector('.message-reactions');
        if (existingReactions) {
            existingReactions.remove();
        }

        // Build new reactions HTML with COMPACT format
        if (message.reactions && Object.keys(message.reactions).length > 0) {
            // Calculate total reactions and find most popular emoji
            let totalReactions = 0;
            let mostPopularEmoji = '';
            let maxCount = 0;

            for (const [emoji, users] of Object.entries(message.reactions)) {
                totalReactions += users.length;
                if (users.length > maxCount) {
                    maxCount = users.length;
                    mostPopularEmoji = emoji;
                }
            }

            const emojiCount = Object.keys(message.reactions).length;
            const displayCount = emojiCount === 1 ? totalReactions : totalReactions + '+';

            // Check if current user reacted to any emoji
            const userIdStr = String(currentUser.userId);
            let userReacted = false;
            for (const users of Object.values(message.reactions)) {
                if (users.some(id => String(id) === userIdStr)) {
                    userReacted = true;
                    break;
                }
            }
            const userClass = userReacted ? 'user-reacted' : '';

            const reactionsHtml = `
                <div class="message-reactions">
                    <div class="reaction-badge-compact ${userClass}" onclick="showReactionDetails('${message.id}')" title="Xem chi ti·∫øt reactions">
                        <span class="reaction-emoji">${mostPopularEmoji}</span>
                        <span class="reaction-count">${displayCount}</span>
                    </div>
                </div>
            `;

            // Insert reactions before message-time
            const messageTime = messageContent.querySelector('.message-time');
            if (messageTime) {
                messageTime.insertAdjacentHTML('beforebegin', reactionsHtml);
            }
        }
    }

    // Show reaction details in centered popup
    async function showReactionDetails(messageId) {
        const messageIdStr = String(messageId);
        const message = currentConversation?.messages.find(m => String(m.id) === messageIdStr);

        if (!message || !message.reactions || Object.keys(message.reactions).length === 0) {
            return;
        }

        const overlay = document.getElementById('reactionDetailsOverlay');
        const content = document.getElementById('reactionDetailsContent');

        let html = '';
        const userIdStr = String(currentUser.userId);

        // Collect all unique user IDs to fetch names
        const allUserIds = new Set();
        for (const userIds of Object.values(message.reactions)) {
            userIds.forEach(id => allUserIds.add(String(id)));
        }

        // Fetch user names from backend
        const userNames = {};
        for (const userId of allUserIds) {
            if (String(userId) === userIdStr) {
                userNames[userId] = 'B·∫°n';
            } else {
                try {
                    const response = await fetch(`/api/users/${userId}`);
                    if (response.ok) {
                        const userData = await response.json();
                        userNames[userId] = userData.fullName || userData.username || `User ${userId}`;
                    } else {
                        userNames[userId] = `User ${userId}`;
                    }
                } catch (error) {
                    console.error('Error fetching user name:', error);
                    userNames[userId] = `User ${userId}`;
                }
            }
        }

        // Build HTML for each emoji group
        for (const [emoji, userIds] of Object.entries(message.reactions)) {
            const isMyReaction = userIds.some(id => String(id) === userIdStr);

            html += `
                <div class="reaction-group">
                    <div class="reaction-group-header">
                        <span class="reaction-group-emoji">${emoji}</span>
                        <span class="reaction-group-count">${userIds.length}</span>
                    </div>
                    <div class="reaction-user-list">
            `;

            // Show users who reacted with this emoji
            for (const userId of userIds) {
                const isCurrentUser = String(userId) === userIdStr;
                const userName = userNames[userId] || `User ${userId}`;

                html += `
                    <div class="reaction-user-item">
                        <span class="reaction-user-name">${userName}</span>
                        ${isCurrentUser ? `<button class="reaction-remove-btn" onclick="removeReaction('${messageId}', '${emoji}'); closeReactionDetails();">Nh·∫•p ƒë·ªÉ g·ª°</button>` : ''}
                    </div>
                `;
            }

            html += `
                    </div>
                </div>
            `;
        }

        content.innerHTML = html;
        overlay.classList.add('show');
    }

    // Close reaction details popup
    function closeReactionDetails(event) {
        if (event && event.target !== event.currentTarget) {
            return; // Only close if clicking overlay, not popup content
        }
        const overlay = document.getElementById('reactionDetailsOverlay');
        overlay.classList.remove('show');
    }

    // Show who reacted to a message (OLD - keep for compatibility)
    function showReactionUsers(messageId, emoji) {
        const message = currentConversation.messages.find(m => m.id === messageId);
        if (!message || !message.reactions) return;

        const overlay = document.getElementById('reactionUsersOverlay');
        const popup = document.getElementById('reactionUsersPopup');
        const content = document.getElementById('reactionUsersContent');

        let html = '';

        for (const [reactionEmoji, userIds] of Object.entries(message.reactions)) {
            // Get user names for these IDs
            const userNames = userIds.map(userId => {
                if (userId === currentUser.userId) return 'You';
                // Try to find the user name from message history
                const userMessage = currentConversation.messages.find(m => m.senderId === userId);
                return userMessage ? userMessage.senderName : 'User';
            });

            html += `
                <div class="reaction-group">
                    <span class="reaction-group-emoji">${reactionEmoji}</span>
                    <span class="reaction-user-list">${userNames.join(', ')}</span>
                </div>
            `;
        }

        // Add remove hint if user has reacted
        const userReacted = message.reactions[emoji] && message.reactions[emoji].includes(currentUser.userId);
        if (userReacted) {
            html += `<div class="remove-reaction-hint" onclick="removeReactionFromPopup('${messageId}', '${emoji}')">Click to remove your reaction</div>`;
        }

        content.innerHTML = html;
        overlay.classList.add('show');
        popup.classList.add('show');
    }

    function removeReactionFromPopup(messageId, emoji) {
        removeReaction(messageId, emoji);
        closeReactionPopup();
    }

    function closeReactionPopup() {
        document.getElementById('reactionUsersOverlay').classList.remove('show');
        document.getElementById('reactionUsersPopup').classList.remove('show');
    }

    // Reply to a message
    function replyToMessage(messageId, senderName, content) {
        const replyBar = document.getElementById('replyStatusBar');
        const senderEl = document.getElementById('replyStatusSender');
        const contentEl = document.getElementById('replyStatusContent');

        currentReplyTo = {
            id: messageId,
            senderName: senderName,
            content: content
        };

        senderEl.textContent = senderName === (currentUser.fullName || currentUser.username) ? 'You' : senderName;
        contentEl.textContent = content.length > 50 ? content.substring(0, 50) + '...' : content;

        replyBar.classList.add('show');
        document.getElementById('messageInput').focus();

        console.log('üìù Replying to message:', messageId);
    }

    function cancelReply() {
        currentReplyTo = null;
        document.getElementById('replyStatusBar').classList.remove('show');
    }

    // Scroll to a specific message (when clicking on reply quote)
    function scrollToMessage(messageId) {
        const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
        if (!messageWrapper) {
            showToast('‚ö†Ô∏è Original message not found', 'warning');
            return;
        }

        // Scroll to message
        messageWrapper.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Highlight the message
        const messageEl = messageWrapper.querySelector('.message');
        messageEl.classList.add('message-highlight');
        setTimeout(() => {
            messageEl.classList.remove('message-highlight');
        }, 1500);
    }

    // Delete a message (soft delete)
    function deleteMessage(messageId) {
        if (!confirm('Delete this message? It will be replaced with "This message has been deleted"')) {
            return;
        }

        if (!currentConversation || !isConnected) {
            showToast('‚ö†Ô∏è Cannot delete message: not connected', 'warning');
            return;
        }

        // Update UI immediately (optimistic update)
        const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageWrapper) {
            const bubbleEl = messageWrapper.querySelector('.message-bubble');
            if (bubbleEl) {
                bubbleEl.classList.add('deleted');
                bubbleEl.innerHTML = 'This message has been deleted <span class="deleted-message-icon" onclick="permanentlyDeleteMessage(\'' + messageId + '\')">üóëÔ∏è</span>';
            }

            // Remove action buttons
            const actionsEl = messageWrapper.querySelector('.message-actions');
            if (actionsEl) {
                actionsEl.remove();
            }
        }

        // Update in conversation messages
        const message = currentConversation?.messages.find(m => m.id === messageId);
        if (message) {
            message.deleted = true;
            message.content = 'This message has been deleted';
        }

        const deleteData = {
            messageId: messageId,
            conversationId: currentConversation.id,
            userId: currentUser.userId
        };

        // Send delete via WebSocket
        stompClient.send('/app/chat.deleteMessage', {}, JSON.stringify(deleteData));

        console.log('üóëÔ∏è Deleted message:', messageId);
    }

    // Permanently delete a message
    function permanentlyDeleteMessage(messageId) {
        if (!confirm('Permanently delete this message? This cannot be undone.')) {
            return;
        }

        if (!currentConversation || !isConnected) {
            showToast('‚ö†Ô∏è Cannot delete message: not connected', 'warning');
            return;
        }

        const deleteData = {
            messageId: messageId,
            conversationId: currentConversation.id,
            userId: currentUser.userId,
            permanent: true
        };

        // Send permanent delete via WebSocket
        stompClient.send('/app/chat.permanentDeleteMessage', {}, JSON.stringify(deleteData));

        // Remove from DOM immediately
        const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageWrapper) {
            messageWrapper.style.transition = 'opacity 0.3s ease';
            messageWrapper.style.opacity = '0';
            setTimeout(() => messageWrapper.remove(), 300);
        }

        console.log('üóëÔ∏è Permanently deleted message:', messageId);
    }

    // Update sendMessage to support replies
    const originalSendMessageWithReply = sendMessage;
    sendMessage = async function() {
        const input = document.getElementById('messageInput');
        const content = input.value.trim();

        // Check if we're replying
        if (currentReplyTo && content && !currentUploadFile) {
            const messageData = {
                conversationId: currentConversation.id,
                senderId: currentUser.userId,
                senderName: currentUser.fullName || currentUser.username,
                senderRole: currentUser.userType,
                receiverId: currentUser.userType === 'CUSTOMER' ? currentConversation.sellerId : currentConversation.customerId,
                content: content,
                messageType: 'TEXT',
                replyToMessageId: currentReplyTo.id,
                replyToSenderName: currentReplyTo.senderName,
                replyToContent: currentReplyTo.content
            };

            // Send message via WebSocket
            if (isConnected) {
                const tempId = 'temp_' + Date.now();
                const tempMessage = {
                    id: tempId,
                    ...messageData,
                    read: false,
                    createdAt: new Date().toISOString(),
                    timestamp: new Date().toISOString()
                };

                displayMessage(tempMessage, true);
                stompClient.send('/app/chat.sendMessage', {}, JSON.stringify(messageData));

                input.value = '';
                updateCharCount();
                cancelReply();

                console.log('‚úÖ Sent reply message');
                return;
            }
        }

        // Handle file upload or normal message
        originalSendMessageWithReply();

        // Clear reply after sending
        if (currentReplyTo) {
            cancelReply();
        }
    };

    // Handle incoming reaction updates
    function handleReactionUpdate(update) {
        console.log('üì® Received reaction update:', update);

        // Skip if this is our own reaction (already updated optimistically)
        if (String(update.userId) === String(currentUser.userId)) {
            console.log('‚è≠Ô∏è Skipping own reaction update (already applied optimistically)');
            return;
        }

        // Find the message in current conversation - convert both IDs to String
        const messageIdStr = String(update.messageId);
        const message = currentConversation?.messages.find(m => String(m.id) === messageIdStr);
        if (!message) {
            console.log('‚ùå Message not found for reaction update:', update.messageId);
            console.log('Available message IDs:', currentConversation?.messages.map(m => m.id));
            return;
        }

        console.log('‚úÖ Processing reaction from other user');

        // Update message reactions
        if (!message.reactions) {
            message.reactions = {};
        }

        if (update.action === 'add') {
            if (!message.reactions[update.emoji]) {
                message.reactions[update.emoji] = [];
            }
            const userIdStr = String(update.userId);
            if (!message.reactions[update.emoji].includes(userIdStr)) {
                message.reactions[update.emoji].push(userIdStr);
                console.log('‚úÖ Added reaction from other user:', update.emoji, userIdStr);
            }
        } else if (update.action === 'remove') {
            if (message.reactions[update.emoji]) {
                const userIdStr = String(update.userId);
                message.reactions[update.emoji] = message.reactions[update.emoji].filter(id => String(id) !== userIdStr);
                if (message.reactions[update.emoji].length === 0) {
                    delete message.reactions[update.emoji];
                }
                console.log('‚úÖ Removed reaction from other user:', update.emoji, userIdStr);
            }
        }

        // üîß UPDATE IN-PLACE for other users' reactions to preserve message position
        const messageWrapper = document.querySelector(`[data-message-id="${update.messageId}"]`);
        if (messageWrapper) {
            updateReactionsDisplay(messageWrapper, message);
            console.log('üé® Updated reactions in-place for other user reaction');
        }
    }

    // Handle incoming delete updates
    function handleDeleteUpdate(update) {
        console.log('üì® Received delete update:', update);

        const messageWrapper = document.querySelector(`[data-message-id="${update.messageId}"]`);

        if (update.permanent) {
            // Permanent delete - Remove from DOM immediately
            if (messageWrapper) {
                messageWrapper.style.transition = 'opacity 0.3s ease';
                messageWrapper.style.opacity = '0';
                setTimeout(() => messageWrapper.remove(), 300);
            }

            // Remove from conversation messages
            if (currentConversation) {
                currentConversation.messages = currentConversation.messages.filter(m => m.id !== update.messageId);
            }
        } else {
            // Soft delete - Update message content immediately
            const message = currentConversation?.messages.find(m => m.id === update.messageId);
            if (message) {
                message.deleted = true;
                message.content = 'This message has been deleted';
            }

            // Update DOM immediately without re-rendering
            if (messageWrapper) {
                const bubbleEl = messageWrapper.querySelector('.message-bubble');
                if (bubbleEl) {
                    bubbleEl.classList.add('deleted');
                    bubbleEl.innerHTML = 'This message has been deleted <span class="deleted-message-icon" onclick="permanentlyDeleteMessage(\'' + update.messageId + '\')">üóëÔ∏è</span>';
                }

                // Remove action buttons
                const actionsEl = messageWrapper.querySelector('.message-actions');
                if (actionsEl) {
                    actionsEl.remove();
                }
            }
        }
    }

    // Subscribe to reaction and delete updates when subscribing to conversation
    const originalSubscribeToConversation = subscribeToConversation;
    subscribeToConversation = function(conversationId) {
        originalSubscribeToConversation(conversationId);

        // Subscribe to reactions
        subscriptions.reactions = stompClient.subscribe(
            '/topic/conversation/' + conversationId + '/reactions',
            function(message) {
                const update = JSON.parse(message.body);
                handleReactionUpdate(update);
            }
        );

        // Subscribe to deletes
        subscriptions.deletes = stompClient.subscribe(
            '/topic/conversation/' + conversationId + '/deletes',
            function(message) {
                const update = JSON.parse(message.body);
                handleDeleteUpdate(update);
            }
        );

        console.log('‚úÖ Subscribed to reactions and deletes for conversation: ' + conversationId);
    };

    /*]]>*/


</script>
</body>
</html>
